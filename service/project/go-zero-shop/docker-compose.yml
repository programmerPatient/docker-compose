version: '3.5'
# 网络配置
networks:
  backend:
    driver: ${NETWORKS_DRIVER}
services:
  golang1.21:                                # 自定义容器名称
    build:
      context: ../../base_server/golang/1.21                  # 指定构建使用的 Dockerfile 文件
    environment:                         # 设置环境变量
      - TZ=${TZ}
    privileged: true
    volumes:                             # 设置挂载目录
      - ${CODE_PATH_HOST}:/var/www:rw                    # 设置挂载目录    
    user: root  # 设置使用 root 用户权限
    ports:
      - "${USERCENTER_API_PORT}:8888"
      - "${ORDER_API_PORT}:8887"
      - "${CARTITEM_API_PORT}:8886"
      - "${PRODUCT_API_PORT}:8885"
    working_dir: /var/www #工作文件夹
    stdin_open: true                     # 打开标准输入，可以接受外部输入
    tty: true
    networks:
      - backend
    restart: always                      # 指定容器退出后的重启策略为始终重启
  golang1.21-2:                                # 自定义容器名称
    build:
      context: ../../base_server/golang/1.21                  # 指定构建使用的 Dockerfile 文件
    environment:                         # 设置环境变量
      - TZ=${TZ}
    privileged: true
    volumes:                             # 设置挂载目录
      - ${CODE_PATH_HOST}:/var/www:rw                    # 设置挂载目录    
    user: root  # 设置使用 root 用户权限
    working_dir: /var/www #工作文件夹
    stdin_open: true                     # 打开标准输入，可以接受外部输入
    tty: true
    networks:
      - backend
    restart: always                      # 指定容器退出后的重启策略为始终重启
  mysql8.0.31:
    build:
      context: ../../base_server/mysql/8.0.31
    environment:
      - TZ=${TZ}
      - MYSQL_USER=${MYSQL8031_USERNAME}                  # 设置 Mysql 用户名称
      - MYSQL_PASSWORD=${MYSQL8031_PASSWORD}              # 设置 Mysql 用户密码
      - MYSQL_ROOT_PASSWORD=${MYSQL8031_ROOT_PASSWORD}    # 设置 Mysql root 用户密码
    privileged: true
    volumes:
      - ${DATA_PATH_HOST}/mysql/8.0.31:/var/lib/mysql        # 引用 .env 配置中 DATA_PATH_HOST 变量，将宿主机上存放 Mysql 数据的目录挂载到容器中 /var/lib/mysql 目录
    ports:
      - "${MYSQL8031_PORT}:3306"                          # 设置容器3306端口映射指定宿主机端口
    networks:
      - backend
    restart: always

  redis5.0:
    build:
      context: ../../base_server/redis/5.0
    environment:
      - TZ=${TZ}
    privileged: true
    volumes:
      - ${DATA_PATH_HOST}/redis/5.0:/data                 # 引用 .env 配置中 DATA_PATH_HOST 变量，将宿主机上存放 Redis 数据的目录挂载到容器中 /data 目录
    ports:
      - "${REDIS50_PORT}:6379"                          # 设置容器6379端口映射指定宿主机端口
    networks:
      - backend
    restart: always
  etcd1:
    build:
        context: ../../base_server/etcd
    container_name: "etcd1"
    restart: "always"
    ports:
      - ${ETCD1_CLIENT_PORT}:2379
    environment:
      - TZ=Asia/Shanghai
      # 允许无认证访问
      - ALLOW_NONE_AUTHENTICATION=yes
      # 名称
      - ETCD_NAME=etcd1
      # 列出这个成员的伙伴 URL 以便通告给集群的其他成员
      - ETCD_INITIAL_ADVERTISE_PEER_URLS=http://etcd1:2380
      # 用于监听伙伴通讯的URL列表
      - ETCD_LISTEN_PEER_URLS=http://0.0.0.0:2380
      # 用于监听客户端通讯的URL列表
      - ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379
      # 初始化集群记号，建议一个集群内的所有节点都设置唯一的token
      - ETCD_INITIAL_CLUSTER_TOKEN=MyEtcd
      # 列出这个成员的客户端URL，通告给集群中的其他成员
      - ETCD_ADVERTISE_CLIENT_URLS=http://etcd1:2379
      # 集群配置，格式是ETCD_NAME=ETCD_INITIAL_ADVERTISE_PEER_URLS
      - ETCD_INITIAL_CLUSTER=etcd1=http://etcd1:2380,etcd2=http://etcd2:2380,etcd3=http://etcd3:2380
      # 初始化集群状态，这里写 new 就行
      - ETCD_INITIAL_CLUSTER_STATE=new
    platform: linux/amd64
    networks:
      - backend
  etcd2:
    build:
      context: ../../base_server/etcd
    container_name: "etcd2"
    restart: "always"
    ports:
      - ${ETCD2_CLIENT_PORT}:2379
    environment:
      - TZ=Asia/Shanghai
      # 允许无认证访问
      - ALLOW_NONE_AUTHENTICATION=yes
      # 名称
      - ETCD_NAME=etcd2
      # 列出这个成员的伙伴 URL 以便通告给集群的其他成员
      - ETCD_INITIAL_ADVERTISE_PEER_URLS=http://etcd2:2380
      # 用于监听伙伴通讯的URL列表
      - ETCD_LISTEN_PEER_URLS=http://0.0.0.0:2380
      # 用于监听客户端通讯的URL列表
      - ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379
      # 初始化集群记号，建议一个集群内的所有节点都设置唯一的token
      - ETCD_INITIAL_CLUSTER_TOKEN=MyEtcd
      # 列出这个成员的客户端URL，通告给集群中的其他成员
      - ETCD_ADVERTISE_CLIENT_URLS=http://etcd2:2379
      # 集群配置，格式是ETCD_NAME=ETCD_INITIAL_ADVERTISE_PEER_URLS
      - ETCD_INITIAL_CLUSTER=etcd1=http://etcd1:2380,etcd2=http://etcd2:2380,etcd3=http://etcd3:2380
      # 初始化集群状态，这里写 new 就行
      - ETCD_INITIAL_CLUSTER_STATE=new
    platform: linux/amd64
    networks:
      - backend
  etcd3:
    build:
      context: ../../base_server/etcd
    container_name: "etcd3"
    restart: "always"
    ports:
      - ${ETCD3_CLIENT_PORT}:2379
    environment:
      - TZ=Asia/Shanghai
      # 允许无认证访问
      - ALLOW_NONE_AUTHENTICATION=yes
        # 名称
      - ETCD_NAME=etcd3
      # 列出这个成员的伙伴 URL 以便通告给集群的其他成员
      - ETCD_INITIAL_ADVERTISE_PEER_URLS=http://etcd3:2380
      # 用于监听伙伴通讯的URL列表
      - ETCD_LISTEN_PEER_URLS=http://0.0.0.0:2380
      # 用于监听客户端通讯的URL列表
      - ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379
      # 初始化集群记号，建议一个集群内的所有节点都设置唯一的token
      - ETCD_INITIAL_CLUSTER_TOKEN=MyEtcd
      # 列出这个成员的客户端URL，通告给集群中的其他成员
      - ETCD_ADVERTISE_CLIENT_URLS=http://etcd3:2379
      # 集群配置，格式是ETCD_NAME=ETCD_INITIAL_ADVERTISE_PEER_URLS
      - ETCD_INITIAL_CLUSTER=etcd1=http://etcd1:2380,etcd2=http://etcd2:2380,etcd3=http://etcd3:2380
      # 初始化集群状态，这里写 new 就行
      - ETCD_INITIAL_CLUSTER_STATE=new
    platform: linux/amd64
    networks:
      - backend
  etcdv3-browser: 
    image: rustyx/etcdv3-browser
    environment:
      - ETCD=http://etcd1:2379,http://etcd2:2379,http://etcd3:2379
    ports:
      - "8077:8081"
  jaeger:
    build:
      context: ../../base_server/jaeger
    environment:
      - TZ=${TZ}
    ports:
      - "${JAEGER_WEB_PORT}:16686"                        # 设置容器16686端口映射指定宿主机端口，用于宿主机访问可视化web
      - "${JAEGER_PORT}:14268"
    networks:
      - backend
    restart: always
  ##################################### Kafka start ##########################################
  kafka1:
    image: 'bitnami/kafka:3.3.1'
    networks:
      - backend
    container_name: kafka11
    user: root
    ports:
      - 9192:9092
      - 9193:9093
    environment:
      ### 通用配置
      # 允许使用kraft，即Kafka替代Zookeeper
      - KAFKA_ENABLE_KRAFT=yes
      # kafka角色，做broker，也要做controller
      - KAFKA_CFG_PROCESS_ROLES=broker,controller
      # 指定供外部使用的控制类请求信息
      - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER
      # 定义kafka服务端socket监听端口
      - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093
      # 定义安全协议
      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT
      # 使用Kafka时的集群id，集群内的Kafka都要用这个id做初始化，生成一个UUID即可
      - KAFKA_KRAFT_CLUSTER_ID=LelM2dIFQkiUFvXCEcqRWA
      # 集群地址
      - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=1@kafka11:9093,2@kafka22:9093,3@kafka33:9093
      # 允许使用PLAINTEXT监听器，默认false，不建议在生产环境使用
      - ALLOW_PLAINTEXT_LISTENER=yes
      # 设置broker最大内存，和初始内存
      - KAFKA_HEAP_OPTS=-Xmx512M -Xms256M 
      # 不允许自动创建主题
      - KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=false

      ### broker配置
      # 定义外网访问地址（宿主机ip地址和端口）
      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://192.168.21.25:9192
      # broker.id，必须唯一
      - KAFKA_BROKER_ID=1
    volumes:
    - ${DATA_PATH_HOST}/kafka1:/bitnami/kafka
  kafka2:
    image: 'bitnami/kafka:3.3.1'
    networks:
      - backend
    container_name: kafka22
    user: root
    ports:
    - 9292:9092
    - 9293:9093
    environment:
    ### 通用配置
    # 允许使用kraft，即Kafka替代Zookeeper
    - KAFKA_ENABLE_KRAFT=yes
    # kafka角色，做broker，也要做controller
    - KAFKA_CFG_PROCESS_ROLES=broker,controller
    # 指定供外部使用的控制类请求信息
    - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER
    # 定义kafka服务端socket监听端口
    - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093
    # 定义安全协议
    - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT
    # 使用Kafka时的集群id，集群内的Kafka都要用这个id做初始化，生成一个UUID即可
    - KAFKA_KRAFT_CLUSTER_ID=LelM2dIFQkiUFvXCEcqRWA
    # 集群地址
    - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=1@kafka11:9093,2@kafka22:9093,3@kafka33:9093
    # 允许使用PLAINTEXT监听器，默认false，不建议在生产环境使用
    - ALLOW_PLAINTEXT_LISTENER=yes
    # 设置broker最大内存，和初始内存
    - KAFKA_HEAP_OPTS=-Xmx512M -Xms256M 
    # 不允许自动创建主题
    - KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=false

    ### broker配置
    # 定义外网访问地址（宿主机ip地址和端口）
    - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://192.168.21.25:9292
    # broker.id，必须唯一
    - KAFKA_BROKER_ID=2
    volumes:
      - ${DATA_PATH_HOST}/kafka2:/bitnami/kafka
  kafka3:
    image: 'bitnami/kafka:3.3.1'
    networks:
      - backend
    container_name: kafka33
    user: root
    ports:
    - 9392:9092
    - 9393:9093
    environment:
    ### 通用配置
    # 允许使用kraft，即Kafka替代Zookeeper
    - KAFKA_ENABLE_KRAFT=yes
    # kafka角色，做broker，也要做controller
    - KAFKA_CFG_PROCESS_ROLES=broker,controller
    # 指定供外部使用的控制类请求信息
    - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER
    # 定义kafka服务端socket监听端口
    - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093
    # 定义安全协议
    - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT
    # 使用Kafka时的集群id，集群内的Kafka都要用这个id做初始化，生成一个UUID即可
    - KAFKA_KRAFT_CLUSTER_ID=LelM2dIFQkiUFvXCEcqRWA
    # 集群地址
    - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=1@kafka11:9093,2@kafka22:9093,3@kafka33:9093
    # 允许使用PLAINTEXT监听器，默认false，不建议在生产环境使用
    - ALLOW_PLAINTEXT_LISTENER=yes
    # 设置broker最大内存，和初始内存
    - KAFKA_HEAP_OPTS=-Xmx512M -Xms256M 
    # 不允许自动创建主题
    - KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=false

    ### broker配置
    # 定义外网访问地址（宿主机ip地址和端口）
    - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://192.168.21.25:9392
    # broker.id，必须唯一
    - KAFKA_BROKER_ID=3
    volumes:
        - ${DATA_PATH_HOST}/kafka3:/bitnami/kafka
  kafka-map:
    build:
      context: ../../base_server/kafka-map
    environment:
      - DEFAULT_USERNAME=${DEFAULT_USERNAME}
      - DEFAULT_PASSWORD=${DEFAULT_PASSWORD}
    ports:
      - ${SERVER_PORT}:8080
##################################### Kafka end ##########################################